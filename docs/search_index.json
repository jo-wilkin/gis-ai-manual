[["index.html", "GIS with AI: A Practical Guide to Claude Code Preface", " GIS with AI: A Practical Guide to Claude Code Dr Jo Wilkin &amp; Claude 2026-02-18 Preface This guide is written for GIS analysts who have no prior experience with AI coding assistants. Whether you work in R, Python, or primarily use desktop GIS tools, this book will walk you through how to use Claude Code to accelerate your GIS workflows — from data cleaning to deploying interactive web applications. The guide is structured in three parts: Getting Started With Claude Code — Setting up your environment, understanding how to work effectively with an AI coding assistant, and establishing good practices from day one. Doing GIS With Claude Code — Practical workflows for common GIS tasks including data cleaning, exploratory analysis, and methodology development. Deploying GIS Products With Claude Code — Taking your work from local scripts to published, shareable products using Posit Connect Cloud. No prior experience with AI tools is assumed. Each chapter includes step-by-step instructions, screenshots, and real-world examples from GIS projects. Who Wrote This and Why? It shouldn’t surprise you that a book that talks about generating code and content from using a tool such as Claude has primarily been written (let’s say 80%) by said tool. But that doesn’t go for saying that I, Jo, didn’t have a hand in this and even this short section is fully human written - no Claude here! I have always enjoyed writing and furthermore enjoyed teaching - bring them together has been one of my favourite things to do! You can check out one of my previous Bookdown projects where I authored over the course of four months a brand new “Geocomputation” course with new tutorials and datasets (in 2020!) for when I was teaching as a Lecturer at University College London. I sunk my heart and soul into that project, everything from the content to the aesthetics were bespoke. I wrote the module during the height of the pandemic, during a time I was navigating the loss of a close family member, and where I had little support to develop the content but huge pressure (naturally!) from students to deliver an effective remote teaching course. Since, the module has been forked, replicated, and reproduced, with just a small byline of credit. All those hours, and woosh, it’s out in the wild with little control on how it’s been used. Perhaps a ‘CC BY’ license wasn’t the best way forward - or I should have written a book! Oh well! So when it came to thinking about bringing this manual alive, why would I not use the very tool it is highlighting. Claude is an incredible advancement to my workflow on helping me bringing my ideas to life, without getting stuck in the nitty gritty of setting up bookdowns, figuring out structures, and even writing the more mundane content. It has saved me an inordinate amount of time to focus on what I wanted to provide others in this area who have an interest in AI for their workflows. The idea for this manual is 100% mine, the chapters, structure, and suggested content as well. As with any tool, Claude has its limitations though, which it does explain quite clearly - and that I’ve added to. Furthermore, our Chapters in Section 3 are primarily written by me due to Claude’s current lack of knowledge about the new Posit Cloud Connect Environment. So it’s not perfect. I’m hoping to add some content, via a blog, on how I see Claude helping particularly in the Spatial Data Science space in democratizing programming knowledge that often it ‘gatekeeped’ away from those setting out to learn. Anyway, for now, I hope I have provided a useful tool for those getting set up in this new venture into AI for (spatial) data science. More to come, I’ve just got to get Claude to remind me I’ve made this promise every few days! "],["introduction.html", "Chapter 1 Introduction 1.1 What is Vibe Coding? 1.2 How Can We Use Vibe Coding in GIS? 1.3 Tips and Tricks 1.4 Limitations", " Chapter 1 Introduction If you’ve spent your career working in ArcGIS Pro, QGIS, or writing R and Python scripts for spatial analysis, the idea of an AI “coding assistant” might feel either exciting or slightly unnerving. This chapter sets the scene — what vibe coding actually is, why it’s relevant to GIS professionals, and some honest reflections on where it helps and where it doesn’t. 1.1 What is Vibe Coding? The term “vibe coding” was coined by Andrej Karpathy in early 2025 to describe a way of programming where you describe what you want in natural language, and an AI assistant writes the code for you. You guide the direction; the AI handles the syntax. It’s a conversation, not a command line. You describe your goal — “read in this shapefile and reproject it to British National Grid” — and Claude writes the code. You don’t need to memorise functions. If you’ve ever spent 20 minutes googling the exact sf::st_transform() syntax or the right EPSG code, vibe coding shortcuts that entirely. You stay in control. Claude proposes changes; you review and approve them. Nothing runs without your say-so. It’s not magic. Claude is generating code based on patterns it’s learned. It can make mistakes, hallucinate package names, or suggest approaches that don’t suit your data. Your domain expertise is what keeps things on track. Think of it less like handing your work to a junior analyst and more like pair programming with a very well-read colleague who types fast but sometimes needs correcting. 1.2 How Can We Use Vibe Coding in GIS? GIS work is particularly well-suited to AI-assisted coding because so much of what we do follows repeatable patterns — load data, clean it, transform it, analyse it, visualise it. Here are some of the ways Claude Code can accelerate your spatial workflows: Data wrangling at speed. Cleaning attribute tables, joining datasets, handling CRS mismatches, converting between formats — Claude can generate these scripts in seconds. Rapid prototyping. Need a quick Leaflet map to check your output? A ggplot to visualise a distribution? Claude can scaffold these without you having to look up the syntax every time. Automating the tedious. Batch processing hundreds of files, renaming columns to a consistent schema, writing QA checks — the tasks that eat hours of your week. Learning new tools. If you’re an R user curious about Python (or vice versa), Claude can translate your familiar workflows into a new language and explain the differences. Documentation as you go. Claude can generate README files, comment your code, and even write metadata — the things we all know we should do but rarely find time for. 1.3 Tips and Tricks A few things we’ve learned from using Claude Code day-to-day on GIS projects: Be specific about your data. Instead of “clean this data”, say “remove rows where the geometry is empty and drop columns that are entirely NA”. The more precise your prompt, the better the output. Tell Claude what language and packages you prefer. Start your session with something like: “I’m working in R with sf, dplyr, and ggplot2. My data is in GeoPackage format.” Work in small steps. Don’t ask Claude to build an entire analysis pipeline in one go. Break it into stages — load, clean, analyse, visualise — and check each one. Use CLAUDE.md files. These are project-level instruction files that Claude reads at the start of every session. Use them to store your preferences, folder structure, and any project-specific context (more on this in Chapter 4). Read what Claude writes. It’s tempting to just approve everything, but you’ll learn more and catch mistakes faster if you actually read the code before accepting it. Don’t be afraid to say “no”. If Claude suggests an approach you don’t like, just tell it. “Actually, let’s use terra instead of raster for this.” It will adapt. 1.4 Limitations It’s important to go in with realistic expectations. Claude Code is a powerful tool, but it’s not a replacement for your expertise: It doesn’t understand your data. Claude can process structures and schemas, but it doesn’t know that your land use classification has a specific local meaning, or that certain boundary codes changed in 2021. Spatial operations can trip it up. Complex geoprocessing chains — especially those involving topology, network analysis, or raster algebra — sometimes produce code that looks right but gives wrong results. Always validate. Large datasets need care. Claude may suggest in-memory approaches that work fine on a sample but fail on your full 2 million-row dataset. Be upfront about data size. It’s not a GIS. Claude Code doesn’t render maps or display spatial data interactively. You’ll still need your GIS software or R/Python environment to view outputs. Reproducibility is your responsibility. Claude can help you write reproducible code, but you need to manage the versioning, environment, and data provenance yourself — which is exactly why we cover Git in Chapter 3. We’ll return to limitations in more detail in Chapter 5. For now, the key takeaway is: Claude Code is a brilliant accelerator when paired with your domain knowledge. It’s not a substitute for it. "],["getting-started-with-claude.html", "Chapter 2 Getting Started with Claude 2.1 Downloading Claude Code 2.2 Setting Up an Account 2.3 Choosing a Program 2.4 Setting Up Folders for Claude 2.5 Restricting Claude to Those Folders 2.6 Why a Folder Structure Template is a Good Idea 2.7 Setting Up Your Window", " Chapter 2 Getting Started with Claude This chapter walks you through everything you need to get Claude Code installed and configured on your machine. If you’ve ever set up a new GIS software environment, you’ll know the drill — a bit of upfront effort that saves enormous time later. We’ll take it step by step. 2.1 Downloading Claude Code Claude Code is a command-line tool that runs in your terminal. It’s not a desktop application with a GUI — it lives in the same terminal you might already use for running R scripts or git commands. You’ll need Node.js installed first. Claude Code runs on Node.js (version 18 or above). If you don’t have it, download it from nodejs.org. Install Claude Code via npm. Open your terminal and run: npm install -g @anthropic-ai/claude-code Verify the installation by typing claude in your terminal. You should see the Claude Code interface appear. Updates happen regularly. Claude Code is actively developed. Run npm update -g @anthropic-ai/claude-code periodically to stay current. If you’re on a managed work machine and can’t install global npm packages, speak to your IT team — they may need to whitelist the package or provide an alternative installation path. 2.2 Setting Up an Account You’ll need an Anthropic account — or your organisation may provide access through a team plan. Claude Code authenticates through your browser. On first launch, Claude Code will open a browser window for you to log in. Once authenticated, the token is stored locally so you won’t need to log in every time. Check your plan. Claude Code usage depends on your subscription. The Pro plan is sufficient for individual use; teams may want the Team or Enterprise plan for shared billing and usage limits. API usage is metered. Unlike the chat interface at claude.ai, Claude Code consumes API credits. Keep an eye on your usage dashboard, especially during heavy sessions. 2.3 Choosing a Program Claude Code is language-agnostic — it can write R, Python, JavaScript, SQL, and more. But your working environment matters: If you’re an R user, you’ll likely want RStudio or VS Code open alongside your terminal. Claude writes the code; you run and inspect it in your IDE. If you’re a Python user, VS Code with a Jupyter extension, or a standalone Jupyter notebook, works well alongside Claude Code. If you work in QGIS or ArcGIS Pro, Claude Code can help you write PyQGIS or ArcPy scripts, processing scripts, and even generate model builder configurations — but you’ll still run them inside your GIS software. Terminal setup matters. Claude Code runs best in a modern terminal — the default macOS Terminal, iTerm2, Windows Terminal, or the integrated terminal in VS Code all work well. The key principle: Claude Code is your writing environment. Your IDE or GIS software is your execution and inspection environment. Keep both open side by side. 2.4 Setting Up Folders for Claude Before you start a session, think about where Claude will be working. Claude Code operates from whatever directory you launch it in, and it can read and write files relative to that location. One project, one folder. Launch Claude Code from the root of your project directory — the same folder where your .Rproj file, environment.yml, or main script lives. Keep your data organised. A clear folder structure means Claude can find your inputs and put outputs in the right place without you having to specify full paths every time. Don’t launch Claude from your home directory. This gives it access to far more than it needs. Always navigate to your project folder first: cd ~/projects/my-gis-analysis claude 2.5 Restricting Claude to Those Folders Why is this important? Claude Code has access to read and modify files on your system. Restricting it to specific project folders prevents accidental changes to files outside your project. This is one of the most important setup steps. This is arguably the single most important configuration step. Claude Code can read and write files — and you want to make sure it’s only touching your project. Use the permission system. When Claude tries to access files or run commands, it will ask for your approval. Pay attention to these prompts, especially in your first few sessions. Set directory restrictions in your Claude Code settings to limit file access to your project directory. This prevents Claude from accidentally reading or modifying files elsewhere on your machine. Be especially careful with: System configuration files .env files containing API keys or credentials Shared network drives Directories containing sensitive or personal data When in doubt, deny. If Claude asks to access something you don’t recognise, say no. You can always grant access later once you understand why it’s needed. For GIS analysts, this is particularly relevant because we often work with data on shared drives or in complex directory structures. Take the time to set this up properly. 2.6 Why a Folder Structure Template is a Good Idea If you’ve worked on enough GIS projects, you know how quickly things descend into chaos without a consistent structure. Files named final_v2_ACTUALLY_FINAL.shp shouldn’t haunt your projects. A consistent folder template helps Claude Code work more effectively because it can predict where things live. Here’s a structure that works well for GIS projects: my-project/ ├── CLAUDE.md # Instructions for Claude Code ├── README.md # Project description ├── data/ │ ├── raw/ # Original, untouched data │ ├── processed/ # Cleaned and transformed data │ └── output/ # Analysis outputs ├── scripts/ │ ├── 01-clean.R # Data cleaning │ ├── 02-analyse.R # Analysis │ └── 03-visualise.R # Visualisation ├── figures/ # Maps and plots └── docs/ # Documentation and metadata Numbered scripts make the workflow order obvious — both to you and to Claude. Separating raw from processed data protects your originals and makes the pipeline reproducible. The CLAUDE.md file at the root is where you store project-specific instructions for Claude (we’ll cover this properly in Chapter 4). You don’t have to use this exact structure, but pick one and stick with it across projects. Consistency is the point. 2.7 Setting Up Your Window How you arrange your screen might sound trivial, but it makes a real difference to your workflow: Side by side. Put your terminal (running Claude Code) on one side of the screen and your IDE or GIS software on the other. You’ll be switching between them constantly. If you have two monitors, dedicate one to Claude Code and your terminal, and the other to your IDE/GIS. Keep a file browser visible. Whether it’s your OS file manager or the file panel in VS Code, being able to see what files Claude is creating or modifying in real time is reassuring. Consider using VS Code’s integrated terminal. This lets you run Claude Code in the same window as your code editor, with the file tree visible in the sidebar. Many GIS analysts find this the most efficient setup. The goal is to minimise friction. You want to see what Claude is doing, review its output, and run the results — all without constantly resizing and switching windows. "],["setting-up-git-for-your-projects.html", "Chapter 3 Setting Up Git for Your Projects 3.1 Why Version Control Matters 3.2 Git with GitHub 3.3 Git with Bitbucket 3.4 Creating Your First Repository 3.5 Connecting Your Local Project to a Remote Repository", " Chapter 3 Setting Up Git for Your Projects If you’ve ever lost work because you saved over the wrong file, or spent time trying to figure out which version of a script actually produced your final output, version control is about to become your best friend. This chapter introduces Git — the tool that tracks every change you make — and shows you how to connect it to a remote platform so your work is backed up and shareable. This matters even more when working with Claude Code, because Claude makes changes fast. Git gives you the safety net to roll back if something goes wrong. 3.1 Why Version Control Matters It’s an undo button for your entire project. Every commit is a snapshot you can return to. If Claude makes a change you don’t like, you can revert it in seconds. It tracks what changed and when. Instead of comparing script_v1.R and script_v2.R by eye, Git shows you exactly which lines were added, removed, or modified. It enables collaboration. If you work in a team, Git prevents the classic “who edited this last?” confusion. Every change is attributed to a person (or, in our case, to you working with Claude). It’s the standard. Whether you’re working in R, Python, or any other language, version control with Git is an industry expectation. If you haven’t used it before, now is an excellent time to start. For GIS analysts specifically, Git tracks your code and configuration — not your data files (which are usually too large). We’ll cover how to handle that distinction shortly. 3.2 Git with GitHub GitHub is the most widely used platform for hosting Git repositories. It’s free for public and private repositories. Create a GitHub account at github.com if you don’t already have one. GitHub provides a web interface for browsing your code, reviewing changes, and managing projects — but the real work happens through Git commands in your terminal. GitHub is particularly well-integrated with Claude Code. Claude can create branches, commit changes, and even open pull requests directly through GitHub’s CLI (gh). For GIS projects, GitHub also supports rendering GeoJSON files directly in the browser, which can be handy for quick visual checks. 3.3 Git with Bitbucket If your organisation uses Atlassian products, you may be working with Bitbucket instead of GitHub. The Git fundamentals are identical — only the hosting platform differs. Bitbucket integrates with Jira and Confluence, which may already be part of your team’s workflow. The setup process is similar — create an account, generate SSH keys or use HTTPS authentication, and connect your local repository to the remote. Claude Code works with Bitbucket repositories in the same way it works with GitHub. The Git commands are identical; only the remote URL changes. Everything in this guide that references GitHub applies equally to Bitbucket unless otherwise noted. 3.4 Creating Your First Repository Let’s create a repository for a GIS project from scratch: Create a project folder on your machine with the structure we discussed in Chapter 2: mkdir ~/projects/my-gis-project cd ~/projects/my-gis-project Initialise Git in that folder: git init Create a .gitignore file. This tells Git which files to not track. For GIS projects, you’ll want to exclude large data files: # Data files (too large for Git) *.shp *.dbf *.shx *.prj *.gpkg *.tif *.tiff *.geojson data/raw/ data/processed/ # R-specific .Rhistory .RData .Rproj.user/ # Python-specific __pycache__/ *.pyc .ipynb_checkpoints/ # OS files .DS_Store Thumbs.db Make your first commit: git add . git commit -m &quot;Initial project structure&quot; The key principle: commit your code, not your data. Large spatial datasets don’t belong in Git. Use shared drives, cloud storage, or dedicated data management tools for those. 3.5 Connecting Your Local Project to a Remote Repository Once you’ve initialised Git locally, you’ll want to connect it to GitHub (or Bitbucket) so your work is backed up and accessible from other machines. Create a new repository on GitHub — go to github.com, click “New repository”, give it a name, and don’t initialise it with a README (you already have local content). Connect your local repo to the remote: git remote add origin https://github.com/yourusername/my-gis-project.git git branch -M main git push -u origin main Verify the connection: git remote -v You should see your GitHub URL listed for both fetch and push. SSH vs HTTPS. If you’ll be pushing frequently, setting up SSH keys avoids having to enter your password each time. GitHub has clear instructions for this. Private repositories are free on GitHub and Bitbucket. Use them for work projects or anything containing sensitive information. This only needs to be done once per project. After the initial setup, you’ll just be committing and pushing as part of your regular workflow — which is exactly what Chapter 4 covers. "],["how-to-work-with-claude-code.html", "Chapter 4 How to Work with Claude Code 4.1 Good Practices 4.2 Using Git with Claude 4.3 Getting Claude to Create Branches and Commit 4.4 Live Examples", " Chapter 4 How to Work with Claude Code This is the chapter you’ll probably come back to most often. It covers the day-to-day practices that make the difference between a frustrating session and a productive one — including a workflow you can follow every single morning. 4.1 Good Practices 4.1.1 Your Daily Workflow: A Cheat Sheet Before we get into the detail, here’s the workflow we recommend every time you sit down to work with Claude Code. Think of it as your morning routine — once it becomes habit, you won’t think twice about it. Your daily workflow with Claude Code. Start each session by creating a branch, do your work in small committed chunks, and merge when you’re happy. ┌─────────────────────────────┐ │ Open terminal in your │ │ project folder │ └──────────────┬──────────────┘ │ ▼ ┌─────────────────────────────┐ │ Launch Claude Code │ │ (type: claude) │ └──────────────┬──────────────┘ │ ▼ ┌─────────────────────────────┐ │ Create a new branch │ │ &quot;Create a branch called │ │ feature/clean-boundaries&quot; │ └──────────────┬──────────────┘ │ ▼ ┌─────────────────────────────┐ │ Do your work │◄──────────┐ │ in small steps │ │ └──────────────┬──────────────┘ │ │ │ ▼ │ ┌─────────────────────────────┐ │ │ Review changes │ │ │ &quot;Show me a git diff&quot; │ │ └──────────────┬──────────────┘ │ │ │ ▼ │ ┌─────────────────────────────┐ │ │ Commit frequently │ │ │ &quot;Commit this with a │ │ │ meaningful message&quot; │ │ └──────────────┬──────────────┘ │ │ │ ▼ │ ┌─────────┐ Yes │ │ More ├────────────────────┘ │ work? │ └────┬────┘ │ No ▼ ┌─────────────────────────────┐ │ Push your branch │ │ &quot;Push this branch │ │ to origin&quot; │ └──────────────┬──────────────┘ │ ▼ ┌─────────────────────────────┐ │ Open a pull request │ │ or merge locally │ └──────────────┬──────────────┘ │ ▼ ┌─────────────────────────────┐ │ ✓ Done for the day │ └─────────────────────────────┘ The golden rule: never work directly on main. Always create a branch, do your work there, and merge back when you’re satisfied. This way, if Claude leads you down a path you don’t like, you can simply delete the branch and start fresh. No harm done. 4.1.2 Step by step Here’s what each stage looks like in practice: Open your terminal and navigate to your project folder: cd ~/projects/my-gis-project claude Create a branch for today’s work. Tell Claude: &gt; “Create a new branch called feature/add-boundary-cleaning” Work in small, reviewable chunks. Instead of asking Claude to write an entire pipeline, ask for one step at a time: &gt; “Read in the boundary shapefile from data/raw/ and check for invalid geometries” Review what Claude has done. After each step, ask: &gt; “Show me a git diff of what’s changed” Commit when you’re happy with a piece of work: &gt; “Commit these changes with the message ‘Add boundary geometry validation’” Repeat steps 3–5 until you’ve finished your task for the day. Push your branch when you’re done: &gt; “Push this branch to origin” Merge or open a pull request once you’re confident the work is complete. 4.1.3 General good practices Beyond the daily workflow, keep these principles in mind: Start each session with context. Remind Claude what you’re working on: “I’m continuing work on the land use classification analysis. We’re in the feature/land-use branch.” Use CLAUDE.md for persistent context. Put your project preferences, data descriptions, and coding standards in a CLAUDE.md file at the root of your project. Claude reads this automatically at the start of every session. Example: # Project: London Green Space Analysis ## Language &amp; packages - R with sf, dplyr, ggplot2, terra - Always use pipe operator |&gt; - Use British English in comments ## Data - Raw data in data/raw/ (do not modify) - All outputs go to data/output/ - CRS: EPSG:27700 (British National Grid) ## Conventions - Script names: 01-clean.R, 02-analyse.R, etc. - Always include a header comment in scripts Ask Claude to explain its choices. If it suggests an approach you’re not familiar with, ask “Why did you use st_make_valid() here instead of st_buffer(0)?” You’ll learn faster this way. Don’t let sessions run too long. Claude Code sessions accumulate context. If you’ve been working for a while and responses start feeling less sharp, start a fresh session. 4.2 Using Git with Claude Claude Code has built-in awareness of Git. You don’t need to switch to a separate terminal for version control — Claude can handle it directly. Checking status: Ask “What’s the current git status?” and Claude will show you tracked, untracked, and modified files. Viewing changes: “Show me the diff” gives you a clear view of what’s changed since the last commit. Switching branches: “Switch to the main branch” or “Checkout the feature/analysis branch”. Viewing history: “Show me the last 5 commits” to understand where you left off. The advantage of doing Git through Claude is that it can explain what it sees. Instead of parsing a raw diff yourself, you can ask: “Summarise the changes I’ve made since the last commit” and get a plain-English description. 4.3 Getting Claude to Create Branches and Commit This is where the workflow diagram above comes to life. Here are the exact phrases you can use: 4.3.1 Creating branches “Create a new branch called feature/clean-postcodes” “Create a branch from main called analysis/spatial-join-update” Claude will run the Git commands for you and confirm the branch has been created and checked out. 4.3.2 Committing changes “Commit all current changes with the message ‘Clean postcode geometries and remove duplicates’” “Stage just the R scripts and commit with a message about the new cleaning function” A few tips for commits: Commit messages should describe the why, not just the what. Not “update script” but “Add postcode validation to catch malformed entries”. Commit often. Small, frequent commits are much easier to review and revert than one massive commit at the end of the day. Let Claude suggest the message. Say “Commit these changes with a meaningful message” and Claude will draft one based on the diff. You can approve or edit it. 4.3.3 Pushing and merging “Push this branch to origin” “Merge this branch into main” Claude will warn you if there are uncommitted changes or conflicts. If a merge conflict arises, Claude can often help you resolve it — just describe which version you want to keep. 4.4 Live Examples Videos and walkthroughs of live coding sessions coming soon. This section will include screen recordings and annotated walkthroughs showing real GIS workflows with Claude Code, including: Cleaning and validating a national boundary dataset Building an interactive Leaflet map from scratch Debugging a failing spatial join Setting up a new project from an empty folder to a working analysis "],["limitations-and-considerations.html", "Chapter 5 Limitations and Considerations 5.1 What Claude Code Does Well 5.2 Where Claude Code Struggles 5.3 Environmental Costs of AI 5.4 Responsible Use", " Chapter 5 Limitations and Considerations We touched on limitations briefly in Chapter 1, but this chapter goes deeper. Understanding where Claude Code excels and where it falls short will save you time, frustration, and — importantly — help you avoid producing incorrect results. Honest reflection on these tools is part of using them responsibly. 5.1 What Claude Code Does Well Let’s start with the positives. Claude Code genuinely accelerates GIS work in these areas: Boilerplate code. Loading libraries, reading data, setting up project structures, writing standard cleaning pipelines — Claude does this faster than you can type it. Translating between languages. Need your R workflow in Python, or vice versa? Claude handles these translations well, preserving the logic while adapting to language-specific conventions. Explaining code. Inherited a colleague’s undocumented script? Paste it in and ask Claude to explain what each section does. This is one of its strongest use cases. Debugging. Paste an error message and the relevant code, and Claude will often identify the issue and suggest a fix immediately. Writing documentation. README files, code comments, function docstrings, metadata templates — Claude produces these quickly and consistently. Repetitive transformations. Renaming columns across multiple datasets, standardising date formats, converting CRS for a batch of files — tedious work that Claude handles reliably. Generating visualisations. Quick exploratory plots, ggplot2 themes, Leaflet maps — Claude can scaffold these rapidly, letting you focus on interpretation rather than syntax. 5.2 Where Claude Code Struggles These are the areas where you need to be most vigilant: Domain-specific spatial logic. Claude doesn’t understand why you’d use a 50-metre buffer versus a 100-metre buffer, or why a particular spatial join needs to be a left join. It can write the code, but the analytical decisions are yours. Complex geoprocessing chains. Operations that involve multiple sequential spatial transformations — dissolve, then buffer, then intersect, then aggregate — sometimes produce subtly wrong results. Always validate the output geometry. CRS and projection issues. Claude generally knows common EPSG codes, but it can get confused with less common or custom projections. Always verify that transformations are correct. Large raster operations. Claude may suggest approaches that load entire rasters into memory. For large Earth observation datasets, you’ll need to guide it toward tile-based or out-of-core processing. Topology and network analysis. These are areas where spatial relationships are complex and errors are hard to spot visually. Extra validation is essential. Keeping up with package changes. Claude’s training data has a cutoff. If a package has recently changed its API (as terra and sf occasionally do), Claude may suggest deprecated syntax. Understanding your specific data. Claude doesn’t know that ward boundaries changed in the 2023 revision, or that your organisation uses a custom classification scheme. You need to provide this context explicitly. Making maps. Claude Code can help you code maps in R or Python — Leaflet, ggplot2, matplotlib — but it shouldn’t be your map-making tool. For anything that requires careful cartographic design, detailed symbology, or presentation-quality output, you should be using dedicated GIS software such as QGIS or ArcGIS. I still use GUI-based GIS for all my map production, and I’d recommend you do the same. Code-generated maps are great for quick exploration; published maps deserve proper cartographic tools. 5.3 Environmental Costs of AI It would be irresponsible to write a guide encouraging AI use without acknowledging the environmental footprint: AI models require significant energy to run. Each query to Claude Code consumes computational resources in data centres powered by electricity. The scale matters. A single query is negligible, but heavy daily use across thousands of users adds up. This is an active area of concern and research in the AI industry. How to think about it practically: Use Claude Code purposefully, not as a chatbot. Have a clear task before you start a session. Avoid repetitive, unnecessary queries. If Claude gave you a good answer, save it rather than asking again. Batch your work. Rather than starting and stopping sessions throughout the day, consolidate your Claude Code work into focused blocks. Context for GIS professionals. Many of us already work with computationally intensive processes — running spatial models, processing satellite imagery, rendering 3D visualisations. AI-assisted coding is an additional energy cost, but it may also reduce total computation by helping you write more efficient code on the first attempt. Stay informed. Anthropic (the company behind Claude) publishes information about their sustainability efforts. As the field evolves, the energy efficiency of these models is improving. This isn’t a reason to avoid using Claude Code, but it is a reason to use it thoughtfully. 5.4 Responsible Use Using AI in your professional work comes with responsibilities beyond the technical: Don’t present AI-generated code as entirely your own work in contexts where that matters (academic submissions, certifications, job interviews). Be transparent about your tools. Validate outputs. This applies to any tool, but it’s especially important with AI. If Claude writes an analysis that produces a number, check that number against your expectations and, where possible, against an independent calculation. Be careful with sensitive data. Claude Code processes your prompts and code. Don’t paste confidential data, personal information, or sensitive organisational details into your prompts unless your organisation’s data policy permits it. Credit appropriately. If Claude Code significantly contributed to a piece of work — particularly in research or published outputs — consider acknowledging it, just as you would any other tool or collaborator. Maintain your skills. It’s tempting to let Claude do everything, but actively understanding the code it produces will keep your skills sharp. Use Claude as a learning tool, not a crutch. Stay critical. Just because Claude says something confidently doesn’t mean it’s correct. This applies to code, explanations, and especially to statistical or methodological advice. Your training and experience are the final quality check. "],["data-cleaning-and-quality-assurance.html", "Chapter 6 Data Cleaning and Quality Assurance 6.1 Why This Chapter Matters 6.2 Common GIS Data Cleaning Tasks 6.3 Building a QA Checklist 6.4 Things to Watch Out For", " Chapter 6 Data Cleaning and Quality Assurance If there’s one task that dominates a GIS analyst’s working life, it’s data cleaning. Estimates vary, but most spatial data scientists spend 60–80% of their time wrangling data before any actual analysis happens. This is where Claude Code can make the biggest immediate difference. 6.1 Why This Chapter Matters Data cleaning is repetitive, rule-based, and often tedious — exactly the kind of work that AI-assisted coding excels at. But it’s also where mistakes are most consequential: a bad join or a dropped geometry can silently cascade through your entire analysis. The approach here is: let Claude write the cleaning code, but always validate the results yourself. 6.2 Common GIS Data Cleaning Tasks Here are the types of tasks where Claude Code adds the most value, along with example prompts you might use: 6.2.1 Geometry validation and repair Check for invalid geometries: “Read in data/raw/boundaries.gpkg and check which features have invalid geometries. Report how many are invalid and what the issues are.” Repair geometries: “Use st_make_valid() to fix any invalid geometries and save the result to data/processed/boundaries_clean.gpkg” Remove empty geometries: “Filter out any features with empty or null geometries” 6.2.2 CRS management Check and standardise CRS: “What CRS is this dataset in? Reproject it to EPSG:27700 (British National Grid)” Handle mixed CRS datasets: “I have three shapefiles that might be in different projections. Check each one and reproject them all to EPSG:27700” 6.2.3 Attribute cleaning Standardise column names: “Rename all columns to lowercase snake_case” Handle missing values: “Show me a summary of NA values by column, then drop rows where the ‘area_name’ field is missing” Fix encoding issues: “Some of the place names have garbled characters. Try to fix the encoding, assuming the original was UTF-8” Standardise categories: “The ‘land_use’ column has inconsistent values — ‘Residential’, ‘residential’, ‘RESIDENTIAL’, and ‘res.’ all appear. Standardise these.” 6.2.4 Joins and merges Spatial joins: “Join the points dataset to the polygon boundaries using st_join. Keep all points even if they don’t fall within a polygon.” Attribute joins: “Join the census data CSV to the boundary polygons on the ‘ward_code’ field. Flag any codes that don’t match.” Identifying join issues: “How many records from each dataset matched? Show me the unmatched records from both sides.” 6.3 Building a QA Checklist A good practice is to ask Claude to generate a QA report at the end of any cleaning step: “Generate a QA summary for the cleaned dataset: number of features, CRS, column names and types, count of NAs per column, geometry type, and bounding box.” This gives you a quick sanity check before moving on. You might even include this as a standard function in every project, stored in your CLAUDE.md as a template Claude can reuse. 6.4 Things to Watch Out For Silent geometry drops. Some operations quietly remove features with invalid geometries. Always compare your row count before and after cleaning. CRS assumptions. If a dataset has no CRS metadata, Claude will guess — and it might guess wrong. Always verify with a visual check in QGIS or by plotting. Encoding traps. Shapefiles are particularly prone to character encoding issues. If attribute values look garbled after cleaning, ask Claude to try different encodings. Join cardinality. A spatial join between points and overlapping polygons can produce duplicate rows. Make sure you understand whether a one-to-one or one-to-many result is expected. "],["exploratory-data-analysis.html", "Chapter 7 Exploratory Data Analysis 7.1 Statistical Summaries 7.2 Spatial Exploration 7.3 Visualisation with Claude 7.4 Structuring Your EDA 7.5 Saving Your EDA Outputs", " Chapter 7 Exploratory Data Analysis Once your data is clean, the next step is understanding what you’re actually working with. Exploratory Data Analysis (EDA) is the process of summarising, visualising, and probing your data before committing to a formal methodology. For spatial data, this means not just looking at attribute distributions but also examining spatial patterns, clustering, and relationships. Claude Code is particularly useful here because EDA is inherently iterative — you look at something, ask a question, look again. The speed at which Claude can generate plots and summaries makes this back-and-forth much faster. 7.1 Statistical Summaries Start every EDA by getting a handle on the basics: Descriptive statistics: “Give me a summary of all numeric columns — mean, median, standard deviation, min, max, and count of NAs.” Distribution checks: “Create histograms for all numeric columns, arranged in a grid.” Categorical summaries: “Show me the frequency of each category in the ‘land_use’ column, sorted by count.” Correlation matrices: “Create a correlation matrix for the numeric variables and visualise it as a heatmap.” 7.2 Spatial Exploration This is where GIS-specific EDA diverges from standard data science: Quick maps: “Plot the boundaries dataset with fill colour based on population density.” Spatial distribution: “Create a map showing the point locations coloured by their classification category.” Clustering checks: “Are these points clustered or evenly distributed? Run a nearest-neighbour analysis.” Spatial autocorrelation: “Calculate Moran’s I for the ‘median_income’ variable using queen contiguity weights.” Outlier detection: “Highlight any polygons where the area is more than 3 standard deviations from the mean.” 7.3 Visualisation with Claude Claude can generate a wide range of plots. Some particularly useful ones for GIS work: Choropleth maps — “Create a choropleth of median house prices by ward, using a sequential colour palette.” Faceted maps — “Show the same boundary dataset faceted by year, so I can see how values changed over time.” Interactive maps — “Create a Leaflet map with popups showing the ward name and population when you click on a polygon.” Bivariate plots — “Create a scatter plot of area vs population with points coloured by region.” Small multiples — “Create a grid of histograms, one per borough, showing the distribution of green space percentage.” A tip: always tell Claude your preferred visualisation library. “Use ggplot2 with the viridis colour palette” or “Use matplotlib with a clean white background” saves iteration on styling. 7.4 Structuring Your EDA A good approach is to work through EDA in a consistent order: Data overview — dimensions, column types, first few rows Missingness — where are the gaps? Distributions — what do the values look like? Spatial patterns — where are things concentrated or sparse? Relationships — how do variables relate to each other? Outliers — what doesn’t fit the pattern? Ask Claude to work through these stages one at a time, reviewing each output before moving on. This prevents the common trap of generating 20 plots at once and not actually looking at any of them properly. 7.5 Saving Your EDA Outputs Save plots to the figures/ directory — “Save this plot as figures/population_density_map.png at 300 DPI.” Generate an EDA report — “Write a brief markdown summary of what we’ve found so far and save it as docs/eda_notes.md.” Commit your EDA work — This is part of your analysis pipeline and should be versioned: “Commit the EDA script and figures with the message ‘Add initial exploratory analysis of ward-level data’.” "],["methodology-development.html", "Chapter 8 Methodology Development 8.1 Using Claude as a Sounding Board 8.2 Implementing Your Analysis 8.3 Iterating on Your Methodology 8.4 Documenting Your Methodology", " Chapter 8 Methodology Development This is where your GIS expertise matters most. Methodology development — choosing and implementing the analytical approach for your project — is the stage where Claude Code shifts from leading to supporting. You decide the method; Claude helps you implement it. That said, Claude can be a surprisingly useful sounding board during the design phase, and it can dramatically speed up the implementation once you’ve settled on an approach. 8.1 Using Claude as a Sounding Board Before writing any code, you can discuss your analytical approach with Claude: Describe your research question: “I want to identify areas of London that are underserved by green space, accounting for population density and distance to the nearest park. What spatial analysis approaches would you suggest?” Compare methods: “What are the trade-offs between using kernel density estimation versus a grid-based accessibility analysis for this problem?” Check feasibility: “I have ward-level population data and point locations for all parks. Is it feasible to run a network-based accessibility analysis, or should I use Euclidean buffers?” Take Claude’s methodological suggestions as starting points, not gospel. It draws on general knowledge and may not be aware of the latest developments in your specific subfield. Cross-reference with your own expertise and published literature. 8.2 Implementing Your Analysis Once you’ve decided on an approach, Claude can help you build it step by step: 8.2.1 Spatial analysis workflows Buffer analysis: “Create 400m, 800m, and 1200m buffers around each park and calculate the population within each buffer zone.” Spatial interpolation: “Use inverse distance weighting to interpolate air quality measurements across the study area. Use a grid resolution of 100m.” Overlay analysis: “Intersect the flood risk zones with the residential land use polygons and calculate the area of residential land at risk.” Accessibility modelling: “Calculate the straight-line distance from each population-weighted centroid to the nearest park.” 8.2.2 Statistical methods Regression: “Run an OLS regression with green space percentage as the dependent variable and deprivation score, population density, and distance to centre as predictors.” Spatial regression: “The OLS residuals are spatially autocorrelated. Fit a spatial lag model instead using the spdep package.” Classification: “Use k-means clustering on the standardised socioeconomic variables to identify neighbourhood typologies.” Significance testing: “Run a chi-squared test to check whether the distribution of land use types differs significantly between inner and outer boroughs.” 8.3 Iterating on Your Methodology Real analysis is rarely linear. You’ll run something, look at the results, and adjust. Claude Code makes this iteration fast: Sensitivity testing: “Re-run the buffer analysis with 500m and 1000m buffers instead, and compare the results.” Trying alternative specifications: “Add an interaction term between deprivation and distance to centre in the regression.” Validating results: “Split the data 70/30 and check how well the model performs on the held-out set.” Comparing approaches: “Run both the IDW and kriging interpolation and create a difference map showing where they disagree.” 8.4 Documenting Your Methodology This is often the most neglected part of a GIS project, and one of the most valuable things Claude can help with: Method documentation: “Write a methods section describing the accessibility analysis we just ran, suitable for a technical report.” Parameter justification: “Document the key parameters we chose (buffer distances, grid resolution, weight function) and the rationale for each.” Reproducibility notes: “Generate a markdown file listing every analytical step, the input data, the parameters used, and the output produced.” Getting Claude to document as you go is far easier than trying to reconstruct your methodology after the fact. Make it part of your workflow, not an afterthought. "],["deploying-r-bookdown-on-posit-connect-cloud.html", "Chapter 9 Deploying R Bookdown on Posit Connect Cloud 9.1 What is Bookdown? 9.2 What is Posit Connect Cloud? 9.3 Setting Up a Bookdown Project with Claude 9.4 Building Locally 9.5 Deploying to Posit Connect Cloud 9.6 Updating Your Deployed Document", " Chapter 9 Deploying R Bookdown on Posit Connect Cloud You’ve done the analysis. You’ve got clean data, solid results, and a collection of scripts that do exactly what you need. Now what? For many GIS projects, the answer is: make it accessible to others. This chapter covers deploying an R Bookdown document — like a technical report, methodology guide, or data documentation — to Posit Connect Cloud so anyone with the link can read it. If this sounds like a big jump from writing R scripts, don’t worry. Claude Code handles most of the configuration, and Posit Connect Cloud takes care of the hosting. 9.1 What is Bookdown? Bookdown is an R package that turns a collection of R Markdown files into a structured, navigable book — as HTML, PDF, or both. You’re reading one right now. This guide is built with Bookdown. It’s ideal for GIS documentation — technical reports, methodology documents, data dictionaries, and training materials that combine text, code, and figures. Each chapter is a separate .Rmd file, which keeps things manageable and makes collaboration easier. 9.2 What is Posit Connect Cloud? Posit Connect Cloud (formerly RStudio Connect Cloud) is a hosting platform for R and Python content — Shiny apps, Bookdown documents, Quarto sites, and more. Free tier available. You can publish up to 5 pieces of content for free, which is plenty for most individual projects. No server management. You publish from your machine; Posit handles the hosting, rendering, and access control. Shareable via URL. Once published, anyone with the link can access your document — useful for sharing results with stakeholders who don’t use R. 9.3 Setting Up a Bookdown Project with Claude Ask Claude to scaffold the project structure for you: “Create a Bookdown project structure for a technical report on our green space accessibility analysis. Include an index file, three content chapters, a references file, and the necessary configuration files.” Claude will generate: index.Rmd — the title page and preface 01-data.Rmd, 02-methods.Rmd, 03-results.Rmd — your content chapters _bookdown.yml — configuration for chapter ordering and output _output.yml — output format settings style.css — optional custom styling 9.4 Building Locally Before deploying, build the book on your machine to check everything renders correctly: “Build the bookdown site and open it in the browser.” Claude will run: bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::gitbook&quot;) Check the output in your browser. Look for: Do all chapters appear in the table of contents? Do figures and maps render correctly? Are code chunks displaying as intended (or hidden, if that’s what you want)? Do cross-references and links work? 9.5 Deploying to Posit Connect Cloud Create a Posit Connect Cloud account at connect.posit.cloud if you don’t have one. Install the rsconnect package if needed: install.packages(&quot;rsconnect&quot;) Configure your account — Posit Connect Cloud will give you an API key. Ask Claude: &gt; “Help me configure rsconnect to publish to Posit Connect Cloud.” Publish: &gt; “Deploy this bookdown project to Posit Connect Cloud.” Claude will guide you through the rsconnect::deployDoc() or rsconnect::deploySite() process, handling the configuration details. 9.6 Updating Your Deployed Document One of the best things about this workflow: updating is trivial. Make your changes locally (ideally on a branch, as per Chapter 4). Rebuild the book. Re-deploy with the same command — it updates the existing publication rather than creating a new one. Ask Claude: “Rebuild the bookdown site and redeploy to Posit Connect Cloud.” Your URL stays the same, so anyone who has the link will see the latest version. "],["deploying-r-shiny-apps-on-posit-connect-cloud.html", "Chapter 10 Deploying R Shiny Apps on Posit Connect Cloud 10.1 What is Shiny? 10.2 Building a GIS Shiny App with Claude 10.3 Testing Locally 10.4 Deploying to Posit Connect Cloud 10.5 Common Deployment Issues 10.6 Updating Your App", " Chapter 10 Deploying R Shiny Apps on Posit Connect Cloud If Bookdown is for sharing static documents, Shiny is for sharing interactive tools. A Shiny app lets your users explore data, filter maps, adjust parameters, and see results in real time — all through a web browser, with no R installation required on their end. For GIS work, Shiny is exceptionally powerful. An interactive map dashboard can communicate spatial patterns far more effectively than a static PDF, and it lets non-technical stakeholders engage with your analysis on their own terms. 10.1 What is Shiny? Shiny is an R package for building interactive web applications directly from R — no HTML, CSS, or JavaScript knowledge required (though Claude can add those if you want to customise). It’s reactive. When a user changes an input (selects a borough, adjusts a slider, picks a date range), the outputs update automatically. It integrates with spatial packages. Leaflet for interactive maps, plotly for interactive charts, DT for searchable data tables — all work seamlessly within Shiny. Common GIS use cases: Interactive map dashboards showing spatial indicators by region Data explorers that let users filter and download subsets of spatial data Scenario comparison tools (e.g., “what if we placed a new facility here?”) Monitoring dashboards showing real-time or regularly updated spatial data 10.2 Building a GIS Shiny App with Claude Claude Code is remarkably effective at building Shiny apps. The combination of UI layout, server logic, and reactive programming is exactly the kind of structured, pattern-based code it handles well. 10.2.1 Getting started “Create a basic Shiny app that displays a Leaflet map of ward boundaries from data/processed/wards.gpkg, coloured by population density, with a dropdown to select different variables.” Claude will generate an app.R file (or split ui.R and server.R files) with: A sidebar panel with input controls A main panel with the Leaflet map Server logic that reads the data and renders the map reactively 10.2.2 Adding interactivity Build up the app’s features incrementally: Filtering: “Add a dropdown to filter wards by borough name.” Click events: “When the user clicks on a ward, show a popup with the ward name, population, and area.” Dynamic legends: “Update the legend when the user selects a different variable.” Data tables: “Add a data table below the map showing the attributes of the currently visible wards.” Download buttons: “Add a button that lets users download the currently filtered data as a CSV.” 10.2.3 Styling “Improve the app’s appearance — use a clean layout with a navbar, add a title, and make the map fill the full width of the main panel.” “Use the bslib package to apply a modern Bootstrap theme.” 10.3 Testing Locally Before deploying, always test your app locally: “Run the Shiny app locally so I can test it.” Claude will run shiny::runApp() and tell you the local URL (usually http://127.0.0.1:XXXX). Check: Does the map render correctly? Do all inputs and filters work as expected? Does it handle edge cases (e.g., filtering to a borough with no data)? Is the performance acceptable with your full dataset? 10.4 Deploying to Posit Connect Cloud The deployment process is similar to Bookdown: Make sure rsconnect is configured (see Chapter 9 if you haven’t done this yet). Deploy the app: &gt; “Deploy this Shiny app to Posit Connect Cloud.” Claude will run the appropriate rsconnect::deployApp() command with your app directory. Check the deployed version — open the URL Posit Connect gives you and test it in the browser. Deployed apps sometimes behave slightly differently to local ones (file paths, data access, package availability). 10.5 Common Deployment Issues A few things that catch people out: File paths. Your app needs to reference data files using relative paths from the app directory. Absolute paths (~/projects/...) will break on the server. Large datasets. Posit Connect Cloud has resource limits. If your app loads a massive spatial dataset on startup, it may time out. Consider pre-processing your data to reduce size, or loading it from a URL. Missing packages. Every package your app uses needs to be listed. Claude will usually handle this correctly, but check the deployment logs if something fails. Data updates. If your data changes regularly, you’ll need a strategy for refreshing it — either redeploying the app with new data, or having the app read from an external source. 10.6 Updating Your App As with Bookdown, updating a deployed Shiny app is straightforward: Make your changes locally (on a branch!). Test locally. Redeploy — it updates the same URL. Ask Claude: “Redeploy the Shiny app to Posit Connect Cloud.” The iterative workflow from Chapter 4 applies here too: branch, develop, test, commit, deploy, merge. Your users always see the latest version at the same URL, and you have full version history through Git. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
